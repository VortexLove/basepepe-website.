<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Compra de Tokens PBJ</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
</head>
<body>
  <h1>Compra de Tokens PBJ</h1>

  <button id="connectButton">Conectar MetaMask</button>
  <div id="status" style="margin: 10px 0; font-weight: bold;"></div>

  <div>
    <label for="ethAmount">Cantidad de ETH (0.01 - 2):</label>
    <input
      type="number"
      id="ethAmount"
      min="0.01"
      max="2"
      step="0.01"
      value="0.01"
      style="width: 80px;"
    />
    <button id="buyButton" disabled>Comprar Tokens</button>
  </div>

  <script>
    const contractAddress = '0x1EfBF9BaD1419c6DE7a0BF28158f563FafC7ab56';
    const abi = [
      'function buyTokens() payable',
      'function presaleActive() view returns (bool)',
      'function presaleEnd() view returns (uint256)',
      'function rate() view returns (uint256)',
      'function minBuy() view returns (uint256)',
      'function maxBuy() view returns (uint256)'
    ];

    let provider;
    let signer;
    let contract;

    const connectButton = document.getElementById('connectButton');
    const buyButton = document.getElementById('buyButton');
    const statusDiv = document.getElementById('status');
    const ethAmountInput = document.getElementById('ethAmount');

    connectButton.onclick = async () => {
      if (typeof window.ethereum !== 'undefined') {
        try {
          provider = new ethers.providers.Web3Provider(window.ethereum);
          await provider.send('eth_requestAccounts', []);
          signer = provider.getSigner();
          contract = new ethers.Contract(contractAddress, abi, signer);
          statusDiv.innerText = 'MetaMask conectado âœ…';
          buyButton.disabled = false;
        } catch (error) {
          statusDiv.innerText = 'Error al conectar MetaMask: ' + error.message;
        }
      } else {
        statusDiv.innerText = 'MetaMask no detectado. Por favor, instala MetaMask.';
      }
    };

    buyButton.onclick = async () => {
      if (!contract) {
        alert('Primero conecta la wallet');
        return;
      }

      try {
        const ethAmount = parseFloat(ethAmountInput.value);
        if (isNaN(ethAmount) || ethAmount <= 0) {
          alert('Introduce un valor vÃ¡lido de ETH');
          return;
        }

        // Obtener valores del contrato
        const presaleActive = await contract.presaleActive();
        const presaleEnd = await contract.presaleEnd();
        const minBuy = await contract.minBuy();
        const maxBuy = await contract.maxBuy();

        const now = Math.floor(Date.now() / 1000);

        if (!presaleActive || now > presaleEnd) {
          alert('La preventa ha finalizado');
          return;
        }

        if (ethAmount < parseFloat(ethers.utils.formatEther(minBuy))) {
          alert(`Cantidad mÃ­nima de compra: ${ethers.utils.formatEther(minBuy)} ETH`);
          return;
        }

        if (ethAmount > parseFloat(ethers.utils.formatEther(maxBuy))) {
          alert(`Cantidad mÃ¡xima de compra: ${ethers.utils.formatEther(maxBuy)} ETH`);
          return;
        }

        const value = ethers.utils.parseEther(ethAmount.toString());

        // Obtener balance del usuario
        const signerAddress = await signer.getAddress();
        const balance = await provider.getBalance(signerAddress);

        // Estimar gas
        const gasEstimate = await contract.estimateGas.buyTokens({ value });

        // Obtener precio gas actual
        const gasPrice = await provider.getGasPrice();

        const totalCost = value.add(gasEstimate.mul(gasPrice));

        if (balance.lt(totalCost)) {
          alert(`Fondos insuficientes.\nBalance: ${ethers.utils.formatEther(balance)} ETH\nNecesitas al menos: ${ethers.utils.formatEther(totalCost)} ETH (ETH a enviar + gas)`);
          statusDiv.innerText = 'Fondos insuficientes para esta compra.';
          return;
        }

        statusDiv.innerText = 'Enviando transacciÃ³n...';

        const tx = await contract.buyTokens({
          value,
          gasLimit: gasEstimate.mul(2) // margen para gas
        });

        statusDiv.innerText = 'TransacciÃ³n enviada: ' + tx.hash;
        await tx.wait();
        statusDiv.innerText = 'Compra exitosa ðŸŽ‰ TxHash: ' + tx.hash;
      } catch (error) {
        console.error('Error detallado:', error);
        let message = error.data?.message || error.message || 'Error desconocido';
        alert('Error al comprar tokens: ' + message);
        statusDiv.innerText = 'Error: ' + message;
      }
    };
  </script>
</body>
</html>
